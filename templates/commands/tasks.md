---
name: tasks
description: "計画を実行可能なタスクに分解します。これは仕様駆動開発ライフサイクルの3番目のステップです。"
---

計画を実行可能なタスクに分解します。

これは仕様駆動開発ライフサイクルの3番目のステップです。

引数として提供されたコンテキストを基に、以下を実行します:

1. リポジトリルートから `scripts/check-task-prerequisites.sh --json` を実行し、FEATURE_DIRとAVAILABLE_DOCSリストを解析します。すべてのパスは絶対パスでなければなりません。
2. 利用可能な設計ドキュメントを読み込んで分析します:
   - 技術スタックとライブラリのためplan.mdを常に読む
   - 存在する場合: エンティティのためdata-model.mdを読む
   - 存在する場合: APIエンドポイントのためcontracts/を読む
   - 存在する場合: 技術的決定のためresearch.mdを読む
   - 存在する場合: テストシナリオのためquickstart.mdを読む
   
   注意: すべてのプロジェクトがすべてのドキュメントを持つわけではありません。例えば:
   - CLIツールはcontracts/を持たないかもしれません
   - シンプルなライブラリはdata-model.mdが不要かもしれません
   - 利用可能なものに基づいてタスクを生成します

3. テンプレートに従ってタスクを生成:
   - `/templates/tasks-template.md` をベースとして使用
   - 以下に基づいて実際のタスクで例のタスクを置き換える:
     * **セットアップタスク**: プロジェクト初期化、依存関係、リンティング
     * **テストタスク [P]**: 契約ごとに1つ、統合シナリオごとに1つ
     * **コアタスク**: エンティティ、サービス、CLIコマンド、エンドポイントごとに1つ
     * **統合タスク**: DB接続、ミドルウェア、ロギング
     * **仕上げタスク [P]**: ユニットテスト、パフォーマンス、ドキュメント

4. タスク生成ルール:
   - 各契約ファイル → [P]でマークされた契約テストタスク
   - data-model内の各エンティティ → [P]でマークされたモデル作成タスク
   - 各エンドポイント → 実装タスク（共有ファイルの場合は並列ではない）
   - 各ユーザーストーリー → [P]でマークされた統合テスト
   - 異なるファイル = 並列可能 [P]
   - 同じファイル = 順次実行（[P]なし）

5. 依存関係によってタスクを順序付け:
   - すべての前にセットアップ
   - 実装前にテスト（TDD）
   - サービス前にモデル
   - エンドポイント前にサービス
   - 統合前にコア
   - 仕上げ前にすべて

6. 並列実行の例を含める:
   - 一緒に実行できる[P]タスクをグループ化
   - 実際のタスクエージェントコマンドを表示

7. FEATURE_DIR/tasks.mdを作成:
   - 実装計画からの正しい機能名
   - 番号付きタスク（T001、T002など）
   - 各タスクの明確なファイルパス
   - 依存関係の注記
   - 並列実行のガイダンス

タスク生成のためのコンテキスト: {ARGS}

tasks.mdはすぐに実行可能でなければなりません - 各タスクはLLMが追加のコンテキストなしで完了できるほど具体的でなければなりません。
